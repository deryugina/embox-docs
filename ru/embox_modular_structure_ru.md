# Модульная структура Embox
Важными особенностями Embox являются *модульность* и *конфигурируемость*.

Под модульностью подразумевается разбиение проекта на небольшие логические части - модули, а под конфигурируемостью - возможность определить характеристики конечной системы, на основе списка требуемых модулей и параметров используемых модулей.

Для этого используется система сборки *Mybuild*, со специальным языком программирования (DSL), позволяющим описывать как модули, так и систему в целом.

При этом программная логика модулей располагается отдельно от описания и разрабатывается на обычном языке программирования (GPL).

## Файлы описания модулей

### Пакеты модулей
Структурно модули организованы в иерархические группы (пространства имен), составленные по функциональной принадлежности.

Данный механизм позволяет избежать коллизий в именах модулей, сохраняя их короткими.

Как правило, имя пакета совпадает с путем в файловой системе, что облегчает поиск файлов модуля в дереве исходного кода.

Пример определения имени пакета:
```java
    package embox.arch
```

### Интерфейсы и абстрактные модули
Интерфейсы для модулей являются прямым аналогом интерфейсов и абстрактных классов в ООП.

Язык описания модулей поддерживает наследование, позволяя ввести понятие *интерфейсов* (модулей без реализации) и *абстрактных модулей* (с частичной реализацией).

Модули, которые реализуют один интерфейс или наследуют общий родительский модуль, взаимозаменяемы до тех пор, пока это не меняет функциональность системы.

Данный подход позволяет пользователю выбирать модуль из всех, что реализуют один интерфейс, но имеющит разные алгоритмы, чтобы обеспечить необходимые свойства системы. 

Для того, чтобы указать, что модуль является наследуемым, нужно использовать ключевое слово ***abstract***.

Пример определения абстрактного модуля:
```java
package embox.arch

//...

abstract module interrupt { }
//...
```

Для того, чтобы указать на наследование, используется ключевое слово ***extends***.

Пример наследования от абстрактного модуля:
```java
    module interrupt_stub extends embox.arch.interrupt {
    //...
    }
```

### Атрибуты модулей
Описание каждого модуля состоит из нескольких возможных атрибутов: `файлы исходного кода`, `опции` и `зависимости`.

#### Файлы исходного кода
Каждый модуль может указывать на список файлов, которые необходимо скомпилировать и включить в итоговый образ на тот случай, если данный модуль будет добавлен в сборку.

Список файлов указывается в атрибуте ***source*** модуля.

Помимо «обычных» файлов на языке Си или ассемблера, можно также добавлять заголовочные файлы и дополнительные линкер-скрипты.

Тип файлов различается по расширению: `.c/.S`, `.h`, `.lds.S`.

**.c/.S** - исходные коды на языке Си или ассемблера. При сборке компилируются и включаются в итоговый образ системы. Во время компиляции есть возможность получить значения опций модуля, к которому относятся эти файлы исходного кода.

**.h** - заголовочные файлы, содержащие объявления и определения, необходимые для реализации модулем какого-либо интерфейса. При сборке для каждого включенного модуля генерируется специальный заголовочный файл, включающий все перечисленные .h-файлы данного модуля, а также модулей, расширяющих данный. Это позволяет использовать различные реализации того или иного интерфейса без изменения исходного кода модулей, которые его используют.

Такой способ абстракции необходим, поскольку различные реализации могут определять ту или иную структуру по-разному, в то время как структура может использоваться другими модулями без знания деталей реализации. То же самое относится и к макросам, inline-функциям и константам.

**.lds.S** - линкер-скрипты, позволяющие влиять на процесс компоновки модулей в итоговый образ. Типичное использование таких скриптов - это добавление новых секций.

Пример того, как задать заголовочный файл с реализацией абстрактного модуля:
```java
    module interrupt_stub extends embox.arch.interrupt {
    	source "interrupt_stub.h"
}
```

Пример того, как задать файл с линкер-скриптом и файла с исходным кодом:
```java
    module static_heap extends heap_place {
        // ...
    	source "heap.lds.S"
    	source "static_heap.c"
        // ...
    }
```

#### Опции
Опции позволяют определить числовые, логические или строковые параметры на этапе конфигурирования.

Данные параметры могут влиять на способ сборки, инициализацию или работу модуля.

Опции также могут иметь значение по умолчанию. Если значения по умолчанию нет, то его нужно указать во время конфигурирования.

Опции разделяются на три типа в зависимости от задаваемого значения.
Тип опции задается после ключевого слова *option* перед именем опции:

 * string - строковые опции
 * number - целочисленные данные
 * boolean - булевое значение - true или false

Чтобы получить значение опции при компиляции исходного кода используются специальные макросы:

 * OPTION_STRING_GET - для получения значения строковых опций
 * OPTION_NUMBER_GET - для числовых опций
 * OPTION_BOOLEAN_GET - для булевых опций

Аргументом макроса выступает имя опции, определенное в my-файле.

#### Зависимости
Зависимости являются способом показать системе сборки, что корректная работа модуля невозможна без других модулей. Список зависимостей может включать интерфейсы. Это значит, что в сборку должен быть включен ровно один модуль, реализующий требуемый интерфейс.

Межмодульные зависимости указываются через атрибут *depends*. В значении атрибута можно перечислять как модули, так и интерфейсы. Система сборки гарантирует, что при включении конкретного модуля, будут добавлены и все его зависимости. В случае зависимости от интерфейса используется одна из его реализаций.

Знание о межмодульных зависимостях используется при подготовке и в момент загрузки системы (см. далее).

В некоторых случаях нужно просто включить нужный модуль без изменения порядка загрузки.
Этот способ используется для таких глобальных модулей как, например: *поддержка многопроцессорности*, *логгирование* или *отладочные утверждения (assert)*.

Из-за того, что у таких модулей нет состояния как такового (вроде «загружен» или «не загружен»), требуется дополнить атрибут *depends* аннотацией *@NoRuntime*.
В этом случае зависимость будет использоваться во время сборки, но не будет определять порядок загрузки модулей относительно друг друга.

### Аннотации
Аннотации применяются для изменения семантики элементов описания. Аннотации позволяют дополнять язык описаний без изменения грамматики, что делает его более гибким.

Пример реализации абстрактного модуля с помощью аннотации:

```java
    @DefaultImpl(embox.arch.generic.interrupt_stub)
    abstract module interrupt { }
```

## Описание конфигурации
Описание модулей используется для создания целевого образа.

Во время конфигурации система сборки позволяет объединить модули системы (модули ядра, драйвера, тесты, приложения) и установить для них параметры, а также указать дополнительные параметры для создания образа под различные аппаратные платформы.


### Структура конфигурации
Конфигурация образа происходит за счёт редактирования файлов конфигурации в каталоге *conf/*. Его содержимое следующее:

 * **lds.conf** - содержит определение карты памяти, которая используется на конкретной аппаратной платформе;
 * **mods.conf** - содержит названия и опции модулей, которые будут включены в образ ОС. Также, для каждого из перечисленных в этом файле модуля можно указать новые значения опций;
 * **rootfs/** -  содержит файлы, которые будут включены в состав файловой системы. Она будет доступна на ранних этапах загрузки.

### Процесс конфигурирования
Использование модуля в образе ОС подразумевает его включение в конфигурацию ОС.

#### Базовая конфигурация
Подготовка конфигурации является длительным процессом. Чтобы сократить время подготовки, используются базовые конфигурации. Их назначение -- предоставить пользователю основу с некоторыми базовыми функциями, которую затем можно менять под свои нужды.

В составе ОС есть несколько конфигураций, предназначенных для использования в качестве базовых. Для каждой платформы подготовлено несколько конфигураций, обладающих разными свойствами и возможностями.

Например, чтобы получить базовую конфигурацию для поддержки платформы x86 -- воспользуйтесь следующей командой:
```
    make confload-x86/qemu
```

Эта команда загружает в каталог `conf` базовую конфигурацию с именем «qemu» для платформы x86.

Список всех базовых конфигураций можно посмотреть и выбрать нужную, набрав:
```
make confload
```

#### Включение модуля в конфигурацию
Список модулей для включения в конфигурацию находится в файле «conf/mods.conf», который имеет структуру:
```
    package genconfig

    configuration conf {
	    [список_модулей]
    }
```
Где **[список_модулей]** -- определяет положение набора строк, каждая из которых определяет включение модуля.

Добавьте новую строку к списку модулей:
```
	include pkg.new_package.empty
```
Чтобы получилось:
```
    package genconfig

    configuration conf {
	    [список_модулей]
        include pkg.new_package.empty
    }
```
Тогда модуль «empty» из пакета «pkg.new_package» будет включен в сборку.

Чтобы проверить непротиворечивость полученной сборки и создать образ ОС, наберите:
```
	make
```
Если всё прошло успешно -- Вы увидите надпись «Build complete».

Убедиться в том, что ОС содержит новый модуль можно запустив ОС на исполнение и выполнить команду lsmod c параметрами -n и empty, которая выведет список модулей, у которых в имени модуля присутствует подстрока “empty”.
Чтобы убедиться, что новый модуль есть в ОС, сделайте следующее:
```
    lsmod -n empty
```
В строке выше мы ввели команду «lsmod» с параметрами «-n» и «empty». Она выводит на экран список модулей, у которых в имени есть подстрока “empty”.

Результатом выполнения lsmod будет:
```
	*  pkg.new_package.empty
```
Это означает, что модуль «pkg.new_package.empty» есть в системе, а символ `*` -- что в данный момент модуль загружен и работает.

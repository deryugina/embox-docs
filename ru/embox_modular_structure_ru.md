# Модульная структура Embox
Важными особенностями Embox являются **модульность** и **конфигурируемость**.

Под **модульностью** мы понимаем разбиение проекта на небольшие логические части - модули, а под **конфигурируемостью** - возможность определить характеристики конечной системы на основе списка модулей и их параметров.

Для этого используется система сборки **Mybuild**, со специальным языком программирования (DSL), позволяющим описывать как модули, так и систему в целом.

При этом программная логика модулей располагается отдельно от описания и разрабатывается на обычном языке программирования (GPL).

## Файлы описания модулей
### Пакеты модулей
Модули организованы в иерархические группы (пространства имен).
Такая структура позволяет избежать путаницы в именах модулей и сделать их короткими.
Как правило, имя пакета совпадает с путем в файловой системе, что облегчает поиск файлов модуля в дереве исходного кода.

*Пример именования пакета:*
```java
    package embox.arch
```

### Интерфейсы и абстрактные модули
Интерфейсы для модулей являются прямым аналогом интерфейсов и абстрактных классов в ООП.

Язык описания модулей поддерживает наследование, позволяя ввести понятие *интерфейсов* (модулей без реализации) и *абстрактных модулей* (с частичной реализацией).

Модули, которые реализуют один интерфейс или наследуют общий родительский модуль, взаимозаменяемы до тех пор, пока это не влияет на функциональность системы.

Данный подход позволяет пользователю выбрать нужный из списка модулей, реализующих один интерфейс, но имеющих разные алгоритмы.

Для того, чтобы указать, что модуль является наследуемым, нужно использовать ключевое слово ***abstract***.

*Пример определения абстрактного модуля:*
```java
    package embox.arch

    //...

    abstract module interrupt { }
    //...
```

Для того, чтобы указать на наследование, используется ключевое слово ***extends***.

*Пример наследования от абстрактного модуля:*
```java
    module interrupt_stub extends embox.arch.interrupt {
    //...
    }
```

### Атрибуты модулей
Описание каждого модуля состоит из нескольких возможных атрибутов: `файлы исходного кода`, `опции` и `зависимости`.

#### Файлы исходного кода
Модуль может указывать на список файлов, которые необходимо скомпилировать и включить в итоговый образ. Это полезно, если данный модуль планируется добавить в сборку.

Список файлов указывается в атрибуте ***source*** модуля.

Помимо «обычных» файлов на языке Си или ассемблера, можно также добавлять заголовочные файлы и дополнительные линкер-скрипты.

Типы файлов различаются по расширению: `.c/.S`, `.h`, `.lds.S`.

**.c/.S** - исходные коды на языке Си или ассемблера. При сборке компилируются и включаются в итоговый образ системы. Во время компиляции есть возможность получить значения опций модуля, к которому относятся эти файлы исходного кода.

**.h** - заголовочные файлы, содержащие объявления и определения, необходимые для реализации модулем какого-либо интерфейса. При сборке для каждого модуля системы генерируется специальный заголовочный файл, включающий все перечисленные .h-файлы данного модуля (а также модулей, расширяющих его). Это позволяет использовать различные реализации того или иного интерфейса без изменения исходного кода модулей, которые его используют.

Такой способ абстракции необходим, поскольку различные реализации могут определять ту или иную структуру по-разному, в то время как структура может использоваться другими модулями без знания деталей реализации. То же самое относится и к макросам, inline-функциям и константам.

**.lds.S** - линкер-скрипты, позволяющие влиять на процесс компоновки модулей в итоговый образ. Типичное использование таких скриптов - это добавление новых секций.

*Пример добавления **.h-файла** в модуль:*
```java
    module interrupt_stub extends embox.arch.interrupt {
    	source "interrupt_stub.h"
    }
```

*Пример добавления **.lds.S-файла** и **.c-файла** в модуль:*
```java
    module static_heap extends heap_place {
        // ...
    	source "heap.lds.S"
    	source "static_heap.c"
        // ...
    }
```

#### Опции
Опции позволяют определить числовые, логические и строковые параметры на этапе конфигурирования/подготовки?.

Данные параметры могут влиять на способ сборки, инициализацию или работу модуля.

Опции также могут иметь значение по умолчанию. Если значения по умолчанию нет, то его нужно указать во время конфигурирования.

Опции разделяются на три типа (в зависимости от значения):

 * **string** - строковые опции
 * **number** - целочисленные данные
 * **boolean** - булевое значение - true или false
 
Тип опции задается после ключевого слова `option` перед именем опции.

Чтобы получить значение опции при компиляции исходного кода используются специальные макросы:

 * OPTION_STRING_GET - для получения значения строковых опций
 * OPTION_NUMBER_GET - для числовых опций
 * OPTION_BOOLEAN_GET - для булевых опций

Аргументом макроса выступает имя опции, определенное в my-файле.

#### Зависимости
Зависимости являются способом показать системе сборки, что корректная работа модуля невозможна без других модулей.

Список зависимостей может включать интерфейсы. Это значит, что в сборку должен быть включен ровно один модуль, реализующий требуемый интерфейс.

Межмодульные зависимости указываются через атрибут *depends*. В значении атрибута можно перечислять как модули, так и интерфейсы. Система сборки гарантирует, что при включении конкретного модуля, будут добавлены и все его зависимости. В случае зависимости от интерфейса используется одна из его реализаций.

В некоторых случаях нужно просто включить нужный модуль без изменения порядка загрузки.
Этот способ используется для таких глобальных модулей как, например: **поддержка многопроцессорности**, **логгирование** или **отладочные утверждения (assert)**.

Из-за того, что у таких модулей нет состояния как такового (вроде «загружен» или «не загружен»), требуется дополнить атрибут *depends* аннотацией *@NoRuntime*.
В этом случае зависимость будет использоваться во время сборки, но не будет определять порядок загрузки модулей.

### Аннотации
**Характеристики аннотаций:**

* применяются для изменения семантики элементов описания
* позволяют дополнять язык описания без изменения грамматики
* делают язык описания более гибким

*Пример реализации абстрактного модуля с помощью аннотации:*
```java
    @DefaultImpl(embox.arch.generic.interrupt_stub)
    abstract module interrupt { }
```

## Описание конфигурации
Описание модулей используется для создания целевого образа.

Во время конфигурации система сборки позволяет объединить модули системы (модули ядра, драйвера, тесты, приложения) и установить для них параметры, а также указать дополнительные параметры для создания образа под различные аппаратные платформы.

### Структура конфигурации
Конфигурация образа происходит за счёт редактирования файлов конфигурации в каталоге **conf/**. Его содержимое следующее:

 * **lds.conf** - содержит определение карты памяти, которая используется на конкретной аппаратной платформе;
 * **mods.conf** - содержит названия и опции модулей, которые будут включены в образ ОС. Также, для каждого из перечисленных в этом файле модуля можно указать новые значения опций;
 * **rootfs/** -  содержит файлы, которые будут включены в состав файловой системы. Она будет доступна на ранних этапах загрузки.

### Процесс конфигурирования
Использование модуля в образе ОС подразумевает его включение в конфигурацию ОС.

#### Базовая конфигурация
Подготовка конфигурации к сборке является длительным процессом. Для экономии времени используют **базовые конфигурации**. Их назначение -- предоставить пользователю основу с некоторыми базовыми функциями, которую затем можно менять под свои нужды.

В ОС есть несколько конфигураций, предназначенных для использования в качестве базовых. Для каждой платформы подготовлено несколько конфигураций, обладающих разными свойствами и возможностями.

*Например, чтобы получить базовую конфигурацию для поддержки платформы x86 -- воспользуйтесь следующей командой:*
```
    make confload-x86/qemu
```

Эта команда загружает в каталог `conf` базовую конфигурацию с именем «qemu» для платформы x86.

*Список всех базовых конфигураций можно посмотреть и выбрать нужную, набрав:*
```
    make confload
```

#### Включение модуля в конфигурацию
*Список модулей для включения в конфигурацию находится в файле «conf/mods.conf», который имеет структуру:*
```
    package genconfig

    configuration conf {
	    [список_модулей]
    }
```
Где **[список_модулей]** -- определяет положение набора строк, каждая из которых определяет включение модуля.

*Добавьте новую строку к списку модулей:*
```
	include pkg.new_package.empty
```
*Чтобы получилось:*
```
    package genconfig

    configuration conf {
	    [список_модулей]
        include pkg.new_package.empty
    }
```
Тогда модуль «empty» из пакета «pkg.new_package» будет включен в сборку.

*Чтобы проверить непротиворечивость полученной сборки и создать образ ОС, наберите:*
```
    make
```
Если всё прошло успешно -- Вы увидите на экране сообщение «Build complete».

*Чтобы убедиться, что новый модуль появился в ОС, сделайте следующее:*
```
    lsmod -n empty
```
В строке выше мы ввели команду «lsmod» с параметрами «-n» и «empty». Она выводит на экран список модулей, у которых в имени есть подстрока «empty».

*Результатом выполнения **lsmod** будет:*
```
    *  pkg.new_package.empty
```
Этот вывод сообщает нам, что модуль «pkg.new_package.empty» есть в системе, а символ `*` -- что в данный момент модуль загружен и работает.

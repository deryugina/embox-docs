# FPS: Полезная библиотека для вывода видео

Из названия библиотеки (FPS -- «frame-per-second») следует, что её можно использовать для подсчёта кадров в секунду. Но она также имеет ряд функций, которые могут помочь Вам в работе с графическим выводом.

## Интерфейс

Название модуля -- `embox.lib.fps`, поэтому Вам следует или добавить `depends embox.lib.fps` в Ваш модуль «Mybuild», или явно вставить `include embox.lib.fps` в `conf/mods.conf` (хотя второй вариант использовать не рекомендуется).

Заголовочный файл: `#include <fps/fps.h>`.

## Основное применение

Для начала убедитесь, что Вы знакомы с интерфейсом фрейм-буфера: [[Frame buffer]].

После того, как Вы получили `struct fb_info *`, Вы можете использовать FPS-библиотеку так же просто, как в следующем примере:
```c
  struct fb_info *fbi = fb_lookup(0);
  fps_set_format("Hello, world!");
  fps_print(fbi);
```

Теперь надпись `Hello, world!` должна появиться в левом верхнем углу экрана. Да, это не выглядит как что-то полезное, поэтому давайте выведем на экран фактическую скорость кадров в секунду:

```c
  struct fb_info *fbi = fb_lookup(0);
  /* Формат по умолчанию -- «Embox FPS=%d» */
  fps_set_format("Hello, world!\nFPS=%d"); /* \n работает в случае с format string */
  while(1) {
        fps_print(fbi);
        msleep(100);
  }
```

Теперь на экране (на второй строчке) должна появиться надпись наподобие «FPS=10».

## Двойная буферизация

Иногда рендеринг сцены занимает много времени, поэтому, если мы отрисовываем сцену непосредственно на базе фрейм-буфера, на экране появятся помехи или т. н. глитчи. Двойная буферизация -- это метод, который позволяет решить эту проблему.

Идея в том, чтобы хранить дополнительный буфер «back» для отрисовки, пока основной фрейм остаётся неизменным.

Ниже представлен первый способ использования «back»-буфера:
```c
struct fb_info *fbi = fb_lookup(0);

fps_enable_swap(fbi);

while (1) {
        uint8_t *current_frame = fps_current_frame_fbi);
        draw_something(current_frame);
        fps_print(fbi);
        /* Переместить содержимое «back»-буфера на экран */
        fps_swap(fbi);
}
```

Способы могут быть более мудрёными, если Вы хотите, чтобы фрейм был помещён в определённую область памяти (например, если это специализированная память конкретного устройства для временного буфера). В этом случае Вы можете установить основу фрейма, используя следующие функции:

```c
  void fps_set_base_frame(struct fb_info *fb, void *base_frame);
  void fps_set_back_frame(struct fb_info *fb, void *base_back_frame);

  /* Простой пример может выглядеть следующим образом */
  struct fb_info *fbi = fb_lookup(0);

  fps_set_base_frame(fbi, some_addr_1);
  fps_set_back_frame(fbi, some_addr_2);

  while (1) {
        uint8_t *current_frame = fps_current_frame_fbi);
        draw_something(current_frame);
        fps_print(fbi);

        /* Переместить содержимое «back»-буфера на экран */
        fps_swap(fbi);
  }
```

Обратите внимание: это будет корректно работать только в случае, если данное устройство вывода видео поддерживает изменение базы фрейм-буфера. В противном случае, будет работать только «простой» пример двойной буферизации.
